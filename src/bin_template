module Main where

import System.IO
import System.Process
import System.Directory
import System.Environment
import Data.List
import Data.Maybe
import Data.Time
import Control.Monad
import Control.Applicative
import Problem_Wrapper
import C_Problem_Wrapper
import qualified C_Pe as C

main :: IO ()
main = do
    args <- getArgs
    check_args args
  where
      check_args args
          | head args == "--help"    = help
          | head args == "--version" = version
          | head args == "-c"        = parse_c (tail args)
          | otherwise                = parse_args args

help :: IO ()
help = putStrLn "Arguments: problem <p>          : Calls the problem_p\nls <(in)complete>    : C\nalls ls_(in)complete\ncount <(in)complete> : Calls count_(in)complete\nopen <p>             : Calls open_problem p\n-c                   : prefix to above to call C_Pe equivelent."

parse_args :: [String] -> IO ()
parse_args args
    | head args == "problem" = call_problem (read (args!!1) :: Int)
    | head args == "ls"      = list (args!!1)
    | head args == "count"   = count (args!!1)
    | head args == "open"    = open_problem (read (args!!1) :: Int)
    | otherwise              = error $ "Unexpected parameter " ++ head args
                               ++ ". Expected [-c,problem <p>,"
                               ++ "ls <(in)complete>,count <(in)complete>,"
                               ++ "open <p>]"

parse_c :: [String] -> IO ()
parse_c args
    | head args == "problem" = c_call_problem (read (args!!1) :: Int)
    | head args == "ls"      = c_list (args!!1)
    | head args == "count"   = c_count (args!!1)
    | head args == "open"    = C.open_problem (read (args!!1) :: Int)
    | otherwise              = error $ "Unexpected parameter " ++ head args
                               ++ ". Expected [problem <p>,ls <(in)complete>,"
                               ++ " count <(in)complete>,open <p>]"


list :: String -> IO ()
list str
    | str == "complete"   = ls_complete
    | str == "incomplete" = ls_incomplete
    | otherwise           = error $ "Unexpected parameter " ++ str 
                            ++ ". Expected complete or incomplete"

c_list :: String -> IO ()
c_list str
    | str == "complete"   = C.ls_complete
    | str == "incomplete" = C.ls_incomplete
    | otherwise           = error $ "Unexpected parameter " ++ str 
                            ++ ". Expected complete or incomplete"
count :: String -> IO Int
count str
    | str == "complete"   = count_complete
    | str == "incomplete" = count_incomplete
    | otherwise           = error $ "Unexpected parameter " ++ str 
                            ++ ". Expected complete or incomplete"

c_count :: String -> IO Int
c_count str
    | str == "complete"   = C.count_complete
    | str == "incomplete" = C.count_incomplete
    | otherwise           = error $ "Unexpected parameter " ++ str 
                            ++ ". Expected complete or incomplete"


ls_complete :: IO [Int]
ls_complete = (map read) . filter (/="") . lines
              <$> readFile "Problems/.complete"

ls_incomplete :: IO [Int]
ls_incomplete = (map read) . filter (/="") . lines
                <$> readFile "Problems/.incomplete"

count_complete :: IO Int
count_complete = length <$> ls_complete

count_incomplete :: IO Int
count_incomplete = length <$> ls_incomplete

open_problem :: Int -> IO ()
open_problem p = do
    s <- check_status p
    if s `elem` ["Complete","Incomplete"]
      then (system $ "emacs Problems/Problem_" ++ show p ++ ".hs &") >> return ()
      else do
          putStr "Problem has not been started, Would you like to start it (Y/n): "
          inp <- getLine
          unless (inp `elem` ["n","N"]) $ (system ("echo \"" ++ problem_template p
                                                   ++ "\" > Problems/Problem_" 
                                                   ++ show p ++ ".hs"))
                     >> (system $ "emacs Problems/Problem_"
                                    ++ show p ++ ".hs &")
                     >> appendFile "Problems/.incomplete" (show p)
                     >> wrap_import p >> mark_incomplete p
  where
      problem_template n = "-- NOT YET COMPLETED.\nmodule Problems.Problem_" 
                           ++ show n ++ "\n    ( problem_" ++ show n 
                           ++ "\n    ) where\n\nproblem_" ++ show n 
                           ++ " = "

check_status :: Int -> IO String
check_status p = do
    cs <- lines <$> readFile "Problems/.complete"
    ws <- lines <$> readFile "Problems/.incomplete"
    return $ check_status' p cs ws
  where
      check_status' p cs ws
          | show p `elem` cs = "Complete"
          | show p `elem` ws = "Incomplete"
          | otherwise = "Not yet started"

-- GENERATED AUTOMATICALLY PAST THIS POINT

wrap_import :: Int -> IO ()
wrap_import _ = return ()

mark_incomplete :: Int -> IO ()
mark_incomplete _ = return ()

version :: IO ()
version = putStrLn 

