module Main where

import System.IO
import System.Process
import System.Directory
import System.Environment
import Data.List
import Data.Maybe
import Data.Time
import Data.Ratio
import Data.Function
import Data.Array
import Data.Char
import Data.Bits
import Control.Monad
import Control.Applicative
import Numeric
import C_Problem_Wrapper
import qualified C_Pe as C
import Utils.Misc
import Utils.Prime
import Utils.Sequence
import Utils.Vector
import Utils.Constant
import Utils.List

main :: IO ()
main = do
    args <- getArgs
    check_args args
  where
      check_args args
          | head args == "--help"    = help
          | head args == "--version" = version
          | head args == "-c"        = parse_c (tail args)
          | otherwise                = parse_args args

help :: IO ()
help = putStrLn "Arguments: problem <p>          : Calls the problem_p\nls <(in)complete>    : C\nalls ls_(in)complete\ncount <(in)complete> : Calls count_(in)complete\nopen <p>             : Calls open_problem p\n-c                   : prefix to above to call C_Pe equivelent."


list :: String -> IO ()
list str
    | str == "complete"   = print =<<ls_complete
    | str == "incomplete" = print =<< ls_incomplete
    | otherwise           = error $ "Unexpected parameter " ++ str 
                            ++ ". Expected complete or incomplete"

c_list :: String -> IO ()
c_list str
    | str == "complete"   = print =<< C.ls_complete
    | str == "incomplete" = print =<< C.ls_incomplete
    | otherwise           = error $ "Unexpected parameter " ++ str 
                            ++ ". Expected complete or incomplete"
count :: String -> IO Int
count str
    | str == "complete"   = count_complete
    | str == "incomplete" = count_incomplete
    | otherwise           = error $ "Unexpected parameter " ++ str 
                            ++ ". Expected complete or incomplete"

c_count :: String -> IO Int
c_count str
    | str == "complete"   = C.count_complete
    | str == "incomplete" = C.count_incomplete
    | otherwise           = error $ "Unexpected parameter " ++ str 
                            ++ ". Expected complete or incomplete"

ls_complete :: IO [Int]
ls_complete = (map read) . filter (/="") . lines
              <$> readFile "Problems/.complete"

ls_incomplete :: IO [Int]
ls_incomplete = (map read) . filter (/="") . lines
                <$> readFile "Problems/.incomplete"

count_complete :: IO Int
count_complete = length <$> ls_complete

count_incomplete :: IO Int
count_incomplete = length <$> ls_incomplete

open_problem :: Int -> IO ()
open_problem p = do
    s <- check_status p
    if s `elem` ["Complete","Incomplete"]
      then (system $ "emacs Problems/Problem_" ++ show p ++ ".hs &") >> return ()
      else do
          putStr "Problem has not been started, Would you like to start it (Y/n): "
          inp <- getLine
          unless (inp `elem` ["n","N"]) $ (system ("echo \"" ++ problem_template p
                                                   ++ "\" > Problems/Problem_" 
                                                   ++ show p ++ ".hs"))
                     >> (system $ "emacs Problems/Problem_"
                                    ++ show p ++ ".hs &")
                     >> appendFile "Problems/.incomplete" (show p)
                     >> wrap_import p >> mark_incomplete p
  where
      problem_template n = "-- NOT YET COMPLETED.\nmodule Problems.Problem_" 
                           ++ show n ++ "\n    ( problem_" ++ show n 
                           ++ "\n    ) where\n\nproblem_" ++ show n 
                           ++ " = "

check_status :: Int -> IO String
check_status p = do
    cs <- lines <$> readFile "Problems/.complete"
    ws <- lines <$> readFile "Problems/.incomplete"
    return $ check_status' p cs ws
  where
      check_status' p cs ws
          | show p `elem` cs = "Complete"
          | show p `elem` ws = "Incomplete"
          | otherwise = "Not yet started"

-- GENERATED AUTOMATICALLY PAST THIS POINT

wrap_import :: Int -> IO ()
wrap_import _ = return ()

mark_incomplete :: Int -> IO ()
mark_incomplete _ = return ()

version :: IO ()
version = putStrLn
